{% extends "base.html" %}
{% block title %}Story Editor{% endblock %}

{% block content %}
<h1>Story Editor</h1>
<p>Story ID: {{ story_id }}</p>

<div class="editor-container">
  <!-- Graph area -->
  <div class="graph-container" id="graph-container">
    <!-- We will dynamically place our node <div> elements here -->
    <!-- We'll also add an SVG for edges below -->
    <svg id="edges-svg" width="3000" height="3000">
      <defs>
        <marker id="arrowhead" markerUnits="strokeWidth" markerWidth="10" markerHeight="10" refX="10" refY="5"
          orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 Z" fill="black" />
        </marker>
      </defs>
      <!-- Lines are inserted here by JS -->
    </svg>
  </div>

  <!-- Sidebar with forms -->
  <div class="editor-sidebar">
    <h2>Node Details</h2>
    <form id="node-form">
      <label>ID</label>
      <input type="text" id="node-id" readonly />

      <label>Type</label>
      <select id="node-type">
        <option value="START">START</option>
        <option value="DIALOG">DIALOG</option>
        <option value="END">END</option>
      </select>

      <label>Speaker</label>
      <input type="text" id="node-speaker" />

      <label>Content</label>
      <textarea id="node-content"></textarea>

      <!-- Left Image -->
      <label>Left Image</label>
      <div class="file-drop-zone" id="left-drop-zone">
        <button type="button" onclick="document.getElementById('node-left-img-file').click()">Choose File</button>
        <span id="left-file-name">No file chosen</span>
        <input type="file" id="node-left-img-file" accept="image/*" style="display:none" />
      </div>
      <input type="text" id="node-left-img" readonly />

      <!-- Right Image -->
      <label>Right Image</label>
      <div class="file-drop-zone" id="right-drop-zone">
        <button type="button" onclick="document.getElementById('node-right-img-file').click()">Choose File</button>
        <span id="right-file-name">No file chosen</span>
        <input type="file" id="node-right-img-file" accept="image/*" style="display:none" />
      </div>
      <input type="text" id="node-right-img" readonly />


      <button type="button" id="save-node-btn">Save Node</button>
    </form>

    <div class="editor-actions">
      <button id="add-node-btn">+ Add Node</button>
    </div>

    <div class="tips">
      <h3>How to connect nodes</h3>
      <p>
        1. <strong>Shift+Click</strong> on a node to start the link.<br />
        2. <strong>Shift+Click</strong> on another node to create the edge.
      </p>
    </div>
  </div>
</div>

<script>
  // -- Setup some global references --
  const storyId = {{ story_id }};
  const graphContainer = document.getElementById("graph-container");
  const edgesSvg = document.getElementById("edges-svg");

  // Our data in memory:
  let nodes = []; // {id, node_type, content, speaker, left_img, right_img, x, y}
  let edges = []; // {from, to, condition}

  // For dragging
  let isDragging = false;   // true once we exceed the threshold and actually move a node
  let dragCandidate = null; // holds info from mousedown, to check threshold
  let dragNode = null;      // which node we’re dragging (once isDragging=true)

  // For selection
  let selectedNode = null;

  // LEFT IMAGE
  const leftDropZone = document.getElementById("left-drop-zone");
  const leftFileInput = document.getElementById("node-left-img-file");
  const leftFileName = document.getElementById("left-file-name");

  leftDropZone.addEventListener("dragover", (e) => {
    e.preventDefault();
    leftDropZone.classList.add("dragover");
  });
  leftDropZone.addEventListener("dragleave", (e) => {
    leftDropZone.classList.remove("dragover");
  });
  leftDropZone.addEventListener("drop", (e) => {
    e.preventDefault();
    leftDropZone.classList.remove("dragover");
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      leftFileInput.files = e.dataTransfer.files;
      leftFileName.textContent = e.dataTransfer.files[0].name;
      // Update the readonly text field with the file name (or path)
      document.getElementById("node-left-img").value = e.dataTransfer.files[0].name;
    }
  });
  leftFileInput.addEventListener("change", (e) => {
    if (leftFileInput.files && leftFileInput.files.length > 0) {
      leftFileName.textContent = leftFileInput.files[0].name;
      document.getElementById("node-left-img").value = leftFileInput.files[0].name;
    }
  });

  // RIGHT IMAGE
  const rightDropZone = document.getElementById("right-drop-zone");
  const rightFileInput = document.getElementById("node-right-img-file");
  const rightFileName = document.getElementById("right-file-name");

  rightDropZone.addEventListener("dragover", (e) => {
    e.preventDefault();
    rightDropZone.classList.add("dragover");
  });
  rightDropZone.addEventListener("dragleave", (e) => {
    rightDropZone.classList.remove("dragover");
  });
  rightDropZone.addEventListener("drop", (e) => {
    e.preventDefault();
    rightDropZone.classList.remove("dragover");
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      rightFileInput.files = e.dataTransfer.files;
      rightFileName.textContent = e.dataTransfer.files[0].value;
      document.getElementById("node-right-img").value = e.dataTransfer.files[0].value;
    }
  });
  rightFileInput.addEventListener("change", (e) => {
    if (rightFileInput.files && rightFileInput.files.length > 0) {
      rightFileName.textContent = rightFileInput.files[0].value;
      document.getElementById("node-right-img").value = rightFileInput.files[0].value;
    }
  });


  // ------------------------------------------------------------------
  //  Render Functions
  // ------------------------------------------------------------------
  function renderAll() {
    renderNodes();
    renderEdges();
  }

  function renderNodes() {
    // Remove old nodes from DOM
    document.querySelectorAll(".story-node").forEach((n) => n.remove());

    nodes.forEach((node) => {
      const el = document.createElement("div");
      el.className = "story-node";
      el.style.left = node.x + "px";
      el.style.top = node.y + "px";

      // Highlight if currently selected
      if (selectedNode && selectedNode.id === node.id) {
        el.classList.add("selected");
      }

      // Title
      const titleDiv = document.createElement("div");
      titleDiv.className = "title";
      titleDiv.innerText = `Node #${node.id}`;
      el.appendChild(titleDiv);

      // Node type
      const typeDiv = document.createElement("div");
      typeDiv.className = "node-type";
      typeDiv.innerText = node.node_type;
      el.appendChild(typeDiv);

      // Delete button for non-START
      if (node.node_type !== "START") {
        const delBtn = document.createElement("span");
        delBtn.className = "delete-btn";
        delBtn.innerText = "×";
        delBtn.title = "Delete node";
        // Stop event so it doesn’t interfere with drag threshold/click
        delBtn.onclick = (e) => {
          e.stopPropagation();
          deleteNode(node.id);
        };
        el.appendChild(delBtn);
      }

      // =========== MOUSEDOWN LOGIC (Possible Drag / Click) ===========
      el.onmousedown = (evt) => {
        evt.stopPropagation(); // Don’t treat it as a background click

        // If CTRL is pressed, we'll handle it in the final click 
        // (the browser usually won't do a "drag" on ctrl+click).
        // So just skip building a "dragCandidate" if ctrl is down.
        if (evt.ctrlKey) {
          return;
        }
        // Otherwise, we might be dragging or just clicking:
        dragCandidate = {
          node,
          startX: evt.clientX,
          startY: evt.clientY,
          offsetX: evt.offsetX,
          offsetY: evt.offsetY,
        };
      };

      // =========== CLICK LOGIC ===========
      el.onclick = (evt) => {
        // If we ended up dragging, the browser won't fire a normal click, 
        // but let's just be safe:
        if (isDragging) {
          return;
        }

        // Check if CTRL+click => create edge from selected node to this node
        if (evt.ctrlKey) {
          // If there's a selected node and it's not the same as this node, create an edge
          if (selectedNode && selectedNode.id !== node.id) {
            createEdge(selectedNode.id, node.id);
          }
          // We do NOT change the selection, so you can chain multiple edges from one node
          return;
        }

        // Otherwise, normal click => toggle selection
        if (selectedNode && selectedNode.id === node.id) {
          // Clicking same node => unselect
          selectedNode = null;
          clearNodeForm();
        } else {
          // Select new node
          selectedNode = node;
          loadNodeForm(node.id);
        }
        renderAll();
      };

      graphContainer.appendChild(el);
    });
  }

  function getIntersection(node, targetX, targetY) {
    // Node dimensions (must match your CSS)
    const halfWidth = 75;
    const halfHeight = 40;

    // Calculate the center of the node
    const centerX = node.x + halfWidth;
    const centerY = node.y + halfHeight;

    // Difference vector from the center to the target point
    let dx = targetX - centerX;
    let dy = targetY - centerY;

    // If the target is exactly at the center, return the center
    if (dx === 0 && dy === 0) {
      return { x: centerX, y: centerY };
    }

    // Calculate the scale factors for reaching the node's border in each direction.
    const scaleX = halfWidth / Math.abs(dx);
    const scaleY = halfHeight / Math.abs(dy);

    // Use the smaller scaling factor so that the point lies exactly on the edge
    const scale = Math.min(scaleX, scaleY);

    return {
      x: centerX + dx * scale,
      y: centerY + dy * scale
    };
  }


  function renderEdges() {
    // Remove old lines
    edgesSvg.querySelectorAll("line.edge").forEach((line) => line.remove());

    edges.forEach((edge) => {
      const fromNode = nodes.find((n) => n.id === edge.from);
      const toNode = nodes.find((n) => n.id === edge.to);
      if (!fromNode || !toNode) return;

      // Calculate the centers of both nodes
      const fromCenter = { x: fromNode.x + 75, y: fromNode.y + 40 };
      const toCenter = { x: toNode.x + 75, y: toNode.y + 40 };

      // Compute the intersection points on the node boundaries
      const startPoint = getIntersection(fromNode, toCenter.x, toCenter.y);
      // For the 'to' node, use the reverse direction (i.e. from its center toward the fromNode)
      const endPoint = getIntersection(toNode, fromCenter.x, fromCenter.y);

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("class", "edge");
      line.setAttribute("marker-end", "url(#arrowhead)");
      line.setAttribute("stroke", "black");
      line.setAttribute("stroke-width", "2");

      line.setAttribute("x1", startPoint.x);
      line.setAttribute("y1", startPoint.y);
      line.setAttribute("x2", endPoint.x);
      line.setAttribute("y2", endPoint.y);
      edgesSvg.appendChild(line);
    });
  }


  // ------------------------------------------------------------------
  //  Document-level mouse events
  // ------------------------------------------------------------------
  document.addEventListener("mousemove", (evt) => {
    if (isDragging && dragNode) {
      moveDraggedNode(evt);
      return;
    }
    if (dragCandidate && !isDragging) {
      const dx = evt.clientX - dragCandidate.startX;
      const dy = evt.clientY - dragCandidate.startY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 5) {
        // Start dragging
        isDragging = true;
        dragNode = dragCandidate.node;
        moveDraggedNode(evt);
      }
    }
  });

  document.addEventListener("mouseup", (evt) => {
    // If we were dragging, stop now
    if (isDragging) {
      isDragging = false;
      dragNode = null;
      dragCandidate = null;
      return;
    }

    // If we had a dragCandidate but never crossed threshold =>
    // the node's onclick handler handles the selection logic.
    if (dragCandidate) {
      dragCandidate = null;
      return;
    }

    // Only unselect if the click was inside the graph container.
    if (graphContainer.contains(evt.target)) {
      if (!evt.ctrlKey) {
        selectedNode = null;
        clearNodeForm();
        renderAll();
      }
    }
  });


  function moveDraggedNode(evt) {
    if (!dragNode || !dragCandidate) return;
    const newX = evt.clientX - graphContainer.offsetLeft - dragCandidate.offsetX;
    const newY = evt.clientY - graphContainer.offsetTop - dragCandidate.offsetY;
    dragNode.x = Math.max(newX, 0);
    dragNode.y = Math.max(newY, 0);
    renderAll();
  }

  // ------------------------------------------------------------------
  //  CRUD Functions
  // ------------------------------------------------------------------
  async function fetchStoryData() {
    // ----- Update Nodes -----
    const resNodes = await fetch(`/api/stories/${storyId}/nodes`);
    const nodesData = await resNodes.json();
    const fetchedNodes = nodesData.nodes; // Array of nodes from server

    // Create a map of fetched nodes by id for quick lookup
    const fetchedMap = new Map(fetchedNodes.map(n => [n.id, n]));

    // Update existing nodes and add new ones
    fetchedNodes.forEach(newNode => {
      const existing = nodes.find(n => n.id === newNode.id);
      if (existing) {
        const x = existing.x;
        const y = existing.y;
        // Update non-positional properties from server
        Object.assign(existing, newNode);
        existing.x = x;
        existing.y = y;
      } else {
        // Arrange new nodes in a grid pattern
        const spacingX = 300; // horizontal spacing between nodes
        const spacingY = 150; // vertical spacing between nodes
        const columns = 5;    // number of columns in the grid
        const index = nodes.length; // current count of nodes
        nodes.push({
          ...newNode,
          x: newNode.x != null ? newNode.x : (index % columns) * spacingX + 50,
          y: newNode.y != null ? newNode.y : Math.floor(index / columns) * spacingY + 50,
        });
      }
    });

    // Remove nodes that are no longer returned from the server
    nodes = nodes.filter(n => fetchedMap.has(n.id));

    // ----- Update Edges -----
    const resEdges = await fetch(`/api/stories/${storyId}/edges`);
    const edgesData = await resEdges.json();
    const fetchedEdges = edgesData.edges; // Array of edges from server

    // We'll define a key for each edge (assuming a combination of from and to is unique)
    const edgeKey = edge => `${edge.from}-${edge.to}`;

    // Create a map of fetched edges for quick lookup
    const fetchedEdgesMap = new Map(fetchedEdges.map(e => [edgeKey(e), e]));

    // Update existing edges and add new ones
    fetchedEdges.forEach(newEdge => {
      const key = edgeKey(newEdge);
      const existingEdge = edges.find(e => edgeKey(e) === key);
      if (existingEdge) {
        Object.assign(existingEdge, newEdge);
      } else {
        edges.push(newEdge);
      }
    });

    // Remove edges that are no longer present
    edges = edges.filter(e => fetchedEdgesMap.has(edgeKey(e)));

    renderAll();
  }


  async function createNode() {
    const payload = {
      node_type: "DIALOG",
      content: "New node",
      speaker: "",
      left_img: "",
      right_img: "",
    };
    await fetch(`/api/stories/${storyId}/nodes`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    await fetchStoryData();
  }

  async function deleteNode(nodeId) {
    const node = nodes.find((n) => n.id === nodeId);
    if (!node) return;
    if (node.node_type === "START") {
      alert("Can't delete the START node!");
      return;
    }
    await fetch(`/api/stories/nodes/${nodeId}`, { method: "DELETE" });
    await fetchStoryData();
  }

  async function createEdge(fromNodeId, toNodeId) {
    const payload = {
      from_node_id: fromNodeId,
      to_node_id: toNodeId,
      condition: "SUCCESS",
    };
    await fetch(`/api/stories/${storyId}/edges`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    await fetchStoryData();
  }

  // ------------------------------------------------------------------
  //  Node Form
  // ------------------------------------------------------------------
  function loadNodeForm(nodeId) {
    const node = nodes.find((n) => n.id === nodeId);
    if (!node) return;
    document.getElementById("node-id").value = node.id;
    document.getElementById("node-type").value = node.node_type;
    document.getElementById("node-speaker").value = node.speaker;
    document.getElementById("node-content").value = node.content;
    document.getElementById("node-left-img").value = node.left_img;
    document.getElementById("node-right-img").value = node.right_img;
  }

  function clearNodeForm() {
    document.getElementById("node-id").value = "";
    document.getElementById("node-type").value = "DIALOG";
    document.getElementById("node-speaker").value = "";
    document.getElementById("node-content").value = "";
    document.getElementById("node-left-img").value = "";
    document.getElementById("node-right-img").value = "";
  }

  async function saveNode() {
    const nodeId = Number(document.getElementById("node-id").value);
    if (!nodeId) {
      return createNode();
    }
    const payload = {
      node_type: document.getElementById("node-type").value,
      speaker: document.getElementById("node-speaker").value,
      content: document.getElementById("node-content").value,
      left_img: document.getElementById("node-left-img").value,
      right_img: document.getElementById("node-right-img").value,
    };
    await fetch(`/api/stories/nodes/${nodeId}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    await fetchStoryData();
  }

  // ------------------------------------------------------------------
  //  DOM Setup
  // ------------------------------------------------------------------
  document.getElementById("add-node-btn").onclick = createNode;
  document.getElementById("save-node-btn").onclick = saveNode;

  // On page load, fetch the story data
  window.addEventListener("load", fetchStoryData);

</script>
{% endblock %}